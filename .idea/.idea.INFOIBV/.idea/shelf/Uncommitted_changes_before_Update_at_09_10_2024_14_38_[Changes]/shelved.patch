Index: Form1.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Windows.Forms;\r\nusing System.IO;\r\nusing System.Text.RegularExpressions;\r\nusing System.Windows.Forms.VisualStyles;\r\n\r\nnamespace INFOIBV\r\n{\r\n    public partial class INFOIBV : Form\r\n    {\r\n        private Bitmap InputImage;\r\n        private Bitmap InputImage2;\r\n        private Bitmap OutputImage;\r\n\r\n        /*\r\n         * this enum defines the processing functions that will be shown in the dropdown (a.k.a. combobox)\r\n         * you can expand it by adding new entries to applyProcessingFunction()\r\n         */\r\n        private enum ProcessingFunctions\r\n        {\r\n            Grayscale,\r\n            Invert,\r\n            AdjustContrast,\r\n            ConvolutionFilter,\r\n            MedianFilter,\r\n            DetectEdges,\r\n            Threshold,\r\n            Pipeline1,\r\n            Pipeline2,\r\n            Pipeline3_1,\r\n            Pipeline3_2,\r\n            Pipeline3_3,\r\n            Pipeline3_4,\r\n            Pipeline3_5,\r\n            And,\r\n            Or,\r\n            Dilate,\r\n            Erode,\r\n            Open,\r\n            Close,\r\n            CountValues,\r\n            TraceBoundary\r\n        }\r\n\r\n        public enum ElementShape\r\n        {\r\n            Square,\r\n            Star\r\n        }\r\n\r\n        /*\r\n         * these are the parameters for your processing functions, you should add more as you see fit\r\n         * it is useful to set them based on controls such as sliders, which you can add to the form\r\n         */\r\n        private byte filterSize = 5;\r\n        private float filterSigma = 1f;\r\n        private byte threshold = 127;\r\n        private byte pipelineThreshold = 25;\r\n\r\n        public INFOIBV()\r\n        {\r\n            InitializeComponent();\r\n            populateCombobox();\r\n            populateFilterSize();\r\n            populateShapes();\r\n        }\r\n\r\n        /*\r\n         * populateCombobox: populates the combobox with items as defined by the ProcessingFunctions enum\r\n         */\r\n        private void populateCombobox()\r\n        {\r\n            foreach (string itemName in Enum.GetNames(typeof(ProcessingFunctions)))\r\n            {\r\n                string ItemNameSpaces = Regex.Replace(Regex.Replace(itemName, @\"(\\P{Ll})(\\P{Ll}\\p{Ll})\", \"$1 $2\"), @\"(\\p{Ll})(\\P{Ll})\", \"$1 $2\");\r\n                comboBox.Items.Add(ItemNameSpaces);\r\n            }\r\n            comboBox.SelectedIndex = 0;\r\n        }\r\n\r\n        private void populateFilterSize()\r\n        {\r\n            for (int i = 3; i < 15; i+=2)\r\n            {\r\n                FilterSize.Items.Add(i);\r\n            }\r\n            FilterSize.SelectedIndex = 0;\r\n        }\r\n\r\n        private void populateShapes()\r\n        {\r\n            foreach (string shape in Enum.GetNames(typeof(ElementShape)))\r\n            {\r\n                string _shape = Regex.Replace(Regex.Replace(shape, @\"(\\P{Ll})(\\P{Ll}\\p{Ll})\", \"$1 $2\"), @\"(\\p{Ll})(\\P{Ll})\", \"$1 $2\");\r\n                StructuringShape.Items.Add(_shape);\r\n            }\r\n            StructuringShape.SelectedIndex = 0;\r\n        }\r\n\r\n        /*\r\n         * loadButton_Click: process when user clicks \"Load\" button\r\n         */\r\n        private void loadImageButton_Click(object sender, EventArgs e)\r\n        {\r\n           if (openImageDialog.ShowDialog() == DialogResult.OK)             // open file dialog\r\n           {\r\n                string file = openImageDialog.FileName;                     // get the file name\r\n                imageFileName.Text = file;                                  // show file name\r\n                if (InputImage != null) InputImage.Dispose();               // reset image\r\n                InputImage = new Bitmap(file);                              // create new Bitmap from file\r\n                if (InputImage.Size.Height <= 0 || InputImage.Size.Width <= 0 ||\r\n                    InputImage.Size.Height > 512 || InputImage.Size.Width > 512) // dimension check (may be removed or altered)\r\n                    MessageBox.Show(\"Error in image dimensions (have to be > 0 and <= 512)\");\r\n                else\r\n                    pictureBox1.Image = (Image) InputImage;                 // display input image\r\n           }\r\n        }\r\n        private void loadImageButton2_Click(object sender, EventArgs e)\r\n        {\r\n            if (openImageDialog.ShowDialog() == DialogResult.OK)             // open file dialog\r\n            {\r\n                string file = openImageDialog.FileName;                     // get the file name\r\n                imageFileName.Text = file;                                  // show file name\r\n                if (InputImage2 != null) InputImage2.Dispose();               // reset image\r\n                InputImage2 = new Bitmap(file);                              // create new Bitmap from file\r\n                if (InputImage2.Size.Height <= 0 || InputImage2.Size.Width <= 0 ||\r\n                    InputImage2.Size.Height > 512 || InputImage2.Size.Width > 512) // dimension check (may be removed or altered)\r\n                    MessageBox.Show(\"Error in image dimensions (have to be > 0 and <= 512)\");\r\n                //else\r\n                    //pictureBox2.Image = (Image) InputImage2;                 // display input image\r\n            }\r\n        }\r\n\r\n        private void comboBox_Click(object sender, EventArgs e)\r\n        {\r\n            if (comboBox.SelectedIndex == 16 || comboBox.SelectedIndex == 17 || comboBox.SelectedIndex == 18 || comboBox.SelectedIndex == 19)\r\n            {\r\n                FilterSize.Visible = true;\r\n                StructuringShape.Visible = true;\r\n                Binary.Visible = true;\r\n                LoadImage2.Visible = false;\r\n            }\r\n            else if (comboBox.SelectedIndex == 14 || comboBox.SelectedIndex == 15)\r\n            {\r\n                FilterSize.Visible = false;\r\n                StructuringShape.Visible = false;\r\n                Binary.Visible = false;\r\n                LoadImage2.Visible = true;\r\n            }\r\n            else\r\n            {\r\n                FilterSize.Visible = false;\r\n                StructuringShape.Visible = false;\r\n                Binary.Visible = false;\r\n                LoadImage2.Visible = false;\r\n            }\r\n        }\r\n\r\n\r\n        /*\r\n         * applyButton_Click: process when user clicks \"Apply\" button\r\n         */\r\n        private void applyButton_Click(object sender, EventArgs e)\r\n        {\r\n            if (comboBox.SelectedIndex == 14 || comboBox.SelectedIndex == 15)\r\n            {\r\n                if (InputImage == null || InputImage2 == null) return; // get out if no input image\r\n                if (OutputImage != null) OutputImage.Dispose(); // reset output image\r\n                OutputImage = new Bitmap(InputImage.Size.Width, InputImage.Size.Height); // create new output image\r\n                Color[,]\r\n                    Image1 = new Color[InputImage.Size.Width,\r\n                        InputImage.Size.Height]; // create array to speed-up operations (Bitmap functions are very slow)\r\n                Color[,] Image2 = new Color[InputImage2.Size.Width, InputImage2.Size.Height];\r\n\r\n                // copy input Bitmap to array            \r\n                for (int x = 0; x < InputImage.Size.Width; x++) // loop over columns\r\n                for (int y = 0; y < InputImage.Size.Height; y++) // loop over rows\r\n                    Image1[x, y] = InputImage.GetPixel(x, y); // set pixel color in array at (x,y)\r\n\r\n                for (int x = 0; x < InputImage2.Size.Width; x++)\r\n                for (int y = 0; y < InputImage2.Size.Height; y++)\r\n                    Image2[x, y] = InputImage2.GetPixel(x, y);\r\n\r\n                // execute image processing steps\r\n                byte[,] workingImage = convertToGrayscale(Image1); // convert image to grayscale\r\n                byte[,] workingImage2 = convertToGrayscale(Image2);\r\n                workingImage = applyProcessingFunction(workingImage, workingImage2); // processing functions\r\n\r\n\r\n                // copy array to output Bitmap\r\n                for (int x = 0; x < workingImage.GetLength(0); x++) // loop over columns\r\n                for (int y = 0; y < workingImage.GetLength(1); y++) // loop over rows\r\n                {\r\n                    Color newColor = Color.FromArgb(workingImage[x, y], workingImage[x, y], workingImage[x, y]);\r\n                    OutputImage.SetPixel(x, y, newColor); // set the pixel color at coordinate (x,y)\r\n                }\r\n\r\n                pictureBox2.Image = (Image)OutputImage; // display output image\r\n            }\r\n            else\r\n            {\r\n                if (InputImage == null) return; // get out if no input image\r\n                if (OutputImage != null) OutputImage.Dispose(); // reset output image\r\n                OutputImage = new Bitmap(InputImage.Size.Width, InputImage.Size.Height); // create new output image\r\n                Color[,]\r\n                    Image1 = new Color[InputImage.Size.Width,\r\n                        InputImage.Size.Height]; // create array to speed-up operations (Bitmap functions are very slow)\r\n\r\n                // copy input Bitmap to array            \r\n                for (int x = 0; x < InputImage.Size.Width; x++) // loop over columns\r\n                for (int y = 0; y < InputImage.Size.Height; y++) // loop over rows\r\n                    Image1[x, y] = InputImage.GetPixel(x, y); // set pixel color in array at (x,y)\r\n\r\n                // execute image processing steps\r\n                byte[,] workingImage = convertToGrayscale(Image1); // convert image to grayscale\r\n                workingImage = applyProcessingFunction(workingImage, new byte[0,0]); // processing functions\r\n\r\n\r\n                // copy array to output Bitmap\r\n                for (int x = 0; x < workingImage.GetLength(0); x++) // loop over columns\r\n                for (int y = 0; y < workingImage.GetLength(1); y++) // loop over rows\r\n                {\r\n                    Color newColor = Color.FromArgb(workingImage[x, y], workingImage[x, y], workingImage[x, y]);\r\n                    OutputImage.SetPixel(x, y, newColor); // set the pixel color at coordinate (x,y)\r\n                }\r\n\r\n                pictureBox2.Image = (Image)OutputImage; // display output image\r\n            }\r\n        }\r\n\r\n        /*\r\n         * applyProcessingFunction: defines behavior of function calls when \"Apply\" is pressed\r\n         */\r\n        private byte[,] applyProcessingFunction(byte[,] workingImage,  byte[,] workingImage2)\r\n        {\r\n            sbyte[,] horizontalKernel = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};                       // Define this kernel yourself\r\n            sbyte[,] verticalKernel = {{-1, -2, -1},{0, 0, 0},{1, 2, 1}};                           // Define this kernel yourself\r\n            switch ((ProcessingFunctions)comboBox.SelectedIndex)\r\n            {\r\n                case ProcessingFunctions.Grayscale:\r\n                    return workingImage;\r\n                case ProcessingFunctions.Invert:\r\n                    return invertImage(workingImage);\r\n                case ProcessingFunctions.AdjustContrast:\r\n                    return adjustContrast(workingImage);\r\n                case ProcessingFunctions.ConvolutionFilter:\r\n                    float[,] filter = createGaussianFilter(filterSize, filterSigma);\r\n                    return convolveImage(workingImage, filter);\r\n                case ProcessingFunctions.MedianFilter:\r\n                    return medianFilter(workingImage, filterSize);\r\n                case ProcessingFunctions.DetectEdges:\r\n                    return edgeMagnitude(workingImage, horizontalKernel, verticalKernel);\r\n                case ProcessingFunctions.Threshold:\r\n                    return thresholdImage(workingImage, threshold);\r\n                case ProcessingFunctions.Pipeline1:\r\n                    return pipeline1(workingImage, filterSigma, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.Pipeline2:\r\n                    return pipeline2(workingImage, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.Pipeline3_1:\r\n                    return pipeline3_1(workingImage, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.Pipeline3_2:\r\n                    return pipeline3_2(workingImage, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.Pipeline3_3:\r\n                    return pipeline3_3(workingImage, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.Pipeline3_4:\r\n                    return pipeline3_4(workingImage, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.Pipeline3_5:\r\n                    return pipeline3_5(workingImage, horizontalKernel, verticalKernel, pipelineThreshold);\r\n                case ProcessingFunctions.And:\r\n                    return (new BinaryImage(thresholdImage(workingImage, threshold)) &&\r\n                            new BinaryImage(thresholdImage(workingImage2, threshold))).ToByteArray();\r\n                case ProcessingFunctions.Or:\r\n                    return (new BinaryImage(thresholdImage(workingImage, threshold)) ||\r\n                            new BinaryImage(thresholdImage(workingImage2, threshold))).ToByteArray();\r\n                case ProcessingFunctions.Dilate:\r\n                    int _filterSize = (FilterSize.SelectedIndex * 2) + 3;\r\n                    ElementShape shape = StructuringShape.SelectedIndex == 0 ? ElementShape.Square : ElementShape.Star;\r\n                    StructuringElement H = new StructuringElement(shape, _filterSize);\r\n                    return Binary.Checked\r\n                        ? (new BinaryImage(workingImage) + H).ToByteArray()\r\n                        : (new GrayScaleImage(workingImage) + H).ToByteArray();\r\n\r\n                case ProcessingFunctions.Erode:\r\n                    int _filterSize2 = (FilterSize.SelectedIndex * 2) + 3;\r\n                    ElementShape shape2 = StructuringShape.SelectedIndex == 0 ? ElementShape.Square : ElementShape.Star;\r\n                    StructuringElement H2 = new StructuringElement(shape2, _filterSize2);\r\n                    return Binary.Checked\r\n                        ? (new BinaryImage(workingImage) - H2).ToByteArray()\r\n                        : (new GrayScaleImage(workingImage) - H2).ToByteArray();\r\n                case ProcessingFunctions.Open:\r\n                    int _filterSize3 = (FilterSize.SelectedIndex * 2) + 3;\r\n                    ElementShape shape3 = StructuringShape.SelectedIndex == 0 ? ElementShape.Square : ElementShape.Star;\r\n                    StructuringElement H3 = new StructuringElement(shape3, _filterSize3);\r\n                    return Binary.Checked\r\n                        ? (new BinaryImage(workingImage) * H3).ToByteArray()\r\n                        : (new GrayScaleImage(workingImage) * H3).ToByteArray();\r\n                case ProcessingFunctions.Close:\r\n                    int _filterSize4 = (FilterSize.SelectedIndex * 2) + 3;\r\n                    ElementShape shape4 = StructuringShape.SelectedIndex == 0 ? ElementShape.Square : ElementShape.Star;\r\n                    StructuringElement H4 = new StructuringElement(shape4, _filterSize4);\r\n                    return Binary.Checked\r\n                        ? (new BinaryImage(workingImage) / H4).ToByteArray()\r\n                        : (new GrayScaleImage(workingImage) / H4).ToByteArray();\r\n                case ProcessingFunctions.CountValues:\r\n                    GrayScaleImage I = new GrayScaleImage(workingImage);\r\n                    var c = I.countValues();\r\n                    return I.ToByteArray();\r\n                case ProcessingFunctions.TraceBoundary:\r\n                    BinaryImage I2 = new BinaryImage(workingImage);\r\n                    return I2.traceBoundary().ToByteArray();\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        int[,] byteArrayToIntArray(byte[,] bytes)\r\n        {\r\n            return map2D(bytes, b => (int)b);\r\n        }\r\n\r\n        byte[,] intArrayToByteArray(int[,] ints)\r\n        {\r\n            return map2D(ints, i => (byte)i);\r\n        }\r\n\r\n\r\n        /*\r\n         * saveButton_Click: process when user clicks \"Save\" button\r\n         */\r\n        private void saveButton_Click(object sender, EventArgs e)\r\n        {\r\n            if (OutputImage == null) return;                                // get out if no output image\r\n            if (saveImageDialog.ShowDialog() == DialogResult.OK)\r\n                OutputImage.Save(saveImageDialog.FileName);                 // save the output image\r\n        }\r\n\r\n\r\n        /*\r\n         * convertToGrayScale: convert a three-channel color image to a single channel grayscale image\r\n         * input:   inputImage          three-channel (Color) image\r\n         * output:                      single-channel (byte) image\r\n         */\r\n        private byte[,] convertToGrayscale(Color[,] inputImage)\r\n        {\r\n            // create temporary grayscale image of the same size as input, with a single channel\r\n            byte[,] tempImage = new byte[inputImage.GetLength(0), inputImage.GetLength(1)];\r\n\r\n            // setup progress bar\r\n            progressBar.Visible = true;\r\n            progressBar.Minimum = 1;\r\n            progressBar.Maximum = InputImage.Size.Width * InputImage.Size.Height;\r\n            progressBar.Value = 1;\r\n            progressBar.Step = 1;\r\n\r\n            // process all pixels in the image\r\n            for (int x = 0; x < InputImage.Size.Width; x++)                 // loop over columns\r\n                for (int y = 0; y < InputImage.Size.Height; y++)            // loop over rows\r\n                {\r\n                    Color pixelColor = inputImage[x, y];                    // get pixel color\r\n                    byte average = (byte)((pixelColor.R + pixelColor.B + pixelColor.G) / 3); // calculate average over the three channels\r\n                    tempImage[x, y] = average;                              // set the new pixel color at coordinate (x,y)\r\n                    progressBar.PerformStep();                              // increment progress bar\r\n                }\r\n\r\n            progressBar.Visible = false;                                    // hide progress bar\r\n\r\n            return tempImage;\r\n        }\r\n        //user definded classes and generic functions\r\n        private static A[,] map2dIndexed<T,A>(T[,] inputImage,Func<T,int,int,A> operation)\r\n        {\r\n            A [,] tempImage = new A [inputImage.GetLength(0), inputImage.GetLength(1)];\r\n\r\n            for (int i = 0; i < inputImage.GetLength(0); i++) \r\n            { \r\n                for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                {\r\n                    tempImage[i, j] = operation(inputImage[i, j],i,j);\r\n                } \r\n            }\r\n            return tempImage;\r\n        }\r\n        private static A[,] map2D<T,A>(T[,] inputImage,Func<T,A> operation)\r\n        {\r\n            A [,] tempImage = new A [inputImage.GetLength(0), inputImage.GetLength(1)];\r\n\r\n            for (int i = 0; i < inputImage.GetLength(0); i++) \r\n            { \r\n                for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                {\r\n                    tempImage[i, j] = operation(inputImage[i, j]);\r\n                } \r\n            }\r\n            return tempImage;\r\n        }\r\n        private static TB Foldl2D<TA, TB>(Func<TA, TB, TB> f,TB startV, TA[,] filter)\r\n        {\r\n            foreach (TA v in filter)\r\n            {\r\n                startV = f(v,startV);\r\n            }\r\n            return startV;\r\n        }\r\n        \r\n        private static TB Foldr2D<TA, TB>(Func<TA, TB, TB> f,TB startV, TA[,] filter)\r\n        {\r\n            IEnumerable<TA> enumerableThing = filter.Cast<TA>();\r\n            foreach (TA v in enumerableThing.Reverse())\r\n            {\r\n                startV = f(v,startV);\r\n            }\r\n            return startV;\r\n        }\r\n        private static IEnumerable<(int x,int y)> EnumerableRange2D(int a, int b)\r\n        {\r\n            return from u in Enumerable.Range(0,a) from v in Enumerable.Range(0,b) select (u, v);\r\n        }\r\n\r\n\r\n        // ====================================================================\r\n        // ============= YOUR FUNCTIONS FOR ASSIGNMENT 1 GO HERE ==============\r\n        // ====================================================================\r\n\r\n        /*\r\n         * invertImage: invert a single channel (grayscale) image\r\n         * input:   inputImage          single-channel (byte) image\r\n         * output:                      single-channel (byte) image\r\n         */\r\n        private byte[,] invertImage(byte[,] inputImage)\r\n        {\r\n            // create temporary grayscale image\r\n            GrayScaleImage tempImage = new GrayScaleImage(new byte[inputImage.GetLength(0), inputImage.GetLength(1)]);\r\n            tempImage.Apply(p => 255 - p);\r\n            return tempImage.ToByteArray();\r\n        }\r\n        /*\r\n         * adjustContrast: create an image with the full range of intensity values used\r\n         * input:   inputImage          single-channel (byte) image\r\n         * output:                      single-channel (byte) image\r\n         */\r\n        private byte[,] adjustContrast(byte[,] inputImage)\r\n        {\r\n            // create temporary grayscale image\r\n            GrayScaleImage tempImage = new GrayScaleImage(new byte[inputImage.GetLength(0), inputImage.GetLength(1)]);\r\n            byte high = tempImage.getMax(inputImage);\r\n            byte low = tempImage.getMin(inputImage);\r\n            byte min = Byte.MinValue;\r\n            byte max = Byte.MaxValue;\r\n\r\n            byte Ca(byte a)\r\n            {\r\n                byte b = (byte)(min + (a - low) * ((max - min) / (high - low)));\r\n                return b;\r\n            }\r\n            \r\n            for (int i = 0; i < tempImage.GetLength((0)); i++)\r\n            {\r\n                for (int j = 0; j < tempImage.GetLength(1); j++)\r\n                {\r\n                    tempImage[i, j] = Ca(inputImage[i, j]);\r\n                }\r\n            }\r\n            \r\n            return tempImage.ToByteArray();\r\n        }\r\n        \r\n\r\n        /*\r\n         * createGaussianFilter: create a Gaussian filter of specific square size and with a specified sigma\r\n         * input:   size                length and width of the Gaussian filter (only odd sizes)\r\n         *          sigma               standard deviation of the Gaussian distribution\r\n         * output:                      Gaussian filter\r\n         */\r\n        private float[,] createGaussianFilter(byte size, float sigma)\r\n        {\r\n            if (size % 2 == 0)\r\n            {\r\n                MessageBox.Show(\"Kernel size is not odd, please set an odd kernal size\");\r\n            }\r\n            // create temporary grayscale image\r\n            float[,] filter = new float[size, size];\r\n            int lengthF = filter.GetLength(0);\r\n            int widthF = filter.GetLength(1);\r\n            if(lengthF % 2 == 0 || widthF == 0){throw new Exception(\"can not place pixel in the middle of filter\");}\r\n            for (int i = -(lengthF-1)/2; i < lengthF-(lengthF-1)/2; i++) \r\n            { \r\n                for (int j = -(widthF-1)/2; j < widthF-(widthF-1)/2; j++)\r\n                {\r\n                    filter[i+(lengthF-1)/2, j+(widthF-1)/2] = (float)(1/(2*Math.PI*(sigma*sigma)) * Math.Pow(Math.E, -((i * i + j * j) / (2 * (sigma * sigma)))));\r\n                } \r\n            }\r\n\r\n            return filter;\r\n        }\r\n        \r\n\r\n        /*\r\n         * convolveImage: apply linear filtering of an input image\r\n         * input:   inputImage          single-channel (byte) image\r\n         *          filter              linear kernel\r\n         * output:                      single-channel (byte) image\r\n         */\r\n        private byte[,] convolveImage(byte[,] inputImage, float[,] filter)\r\n        {\r\n            // create temporary grayscale image\r\n            GrayScaleImage tempImage = new GrayScaleImage(new Byte[inputImage.GetLength(0), inputImage.GetLength(1)]);\r\n\r\n            for (int u = 0; u < inputImage.GetLength(0); u++) \r\n            { \r\n                for (int v = 0; v < inputImage.GetLength(1); v++)\r\n                {\r\n                    tempImage[u, v] = CalcConvulation(u, v, inputImage, filter);\r\n                } \r\n            }\r\n\r\n            return tempImage.ToByteArray();\r\n        }\r\n\r\n        private float Clamp(float input)\r\n        {\r\n            if (input < 0) return 0f;\r\n            if (input > 255) return 255f;\r\n            return input;\r\n        }\r\n        \r\n        private byte CalcConvulation(int u,int v,byte[,] inputImage,float[,] filter)\r\n        {\r\n            float r = 0;\r\n            int length = inputImage.GetLength(0);\r\n            int width = inputImage.GetLength(1);\r\n            int lengthF = filter.GetLength(0);\r\n            int widthF = filter.GetLength(1);\r\n            if(lengthF % 2 == 0 || widthF == 0){throw new Exception(\"can not place pixel in the middle of filter\");}\r\n            for (int i = -(lengthF-1)/2; i < lengthF-(lengthF-1)/2; i++) \r\n            { \r\n                for (int j = -(widthF-1)/2; j < widthF-(widthF-1)/2; j++)\r\n                {\r\n                    if(0 <= u-i && length > u-i && 0 <= v-j && width > v-j)\r\n                    {r += inputImage[u - i, v - j] * filter[i+(lengthF-1)/2,j+(widthF-1)/2];}\r\n                } \r\n            }\r\n            return (byte)Clamp(r);\r\n        }\r\n\r\n\r\n        /*\r\n         * medianFilter: apply median filtering on an input image with a kernel of specified size\r\n         * input:   inputImage          single-channel (byte) image\r\n         *          size                length/width of the median filter kernel\r\n         * output:                      single-channel (byte) image\r\n         */\r\n        private byte[] sortedFilterKernel(byte[,] inputImage, byte size, int x, int y)\r\n        {\r\n            List<byte> retImg = new List<byte>(size*size);\r\n            int range = (size - 1) / 2;\r\n            for (int i = x-range; i < x+range ; i++)\r\n            {\r\n                if (i < 0) continue;\r\n                if (i > inputImage.GetLength(0)) break;\r\n                for (int j = y-range; j < y+range; j++)\r\n                {\r\n                    if (j < 0) continue;\r\n\r\n                    if (j > inputImage.GetLength((1))) break;\r\n                    retImg.Add(inputImage[x, y]);\r\n                }\r\n            }\r\n            retImg.Sort();\r\n            return retImg.ToArray();\r\n        }\r\n        \r\n        private byte[,] medianFilter(byte[,] inputImage, byte size)\r\n        {\r\n            if (size % 2 == 0)\r\n            {\r\n                MessageBox.Show(\"Kernel size is not odd, please set an odd kernal size\");\r\n            }\r\n            // create temporary grayscale image\r\n            byte[,] tempImage = new byte[inputImage.GetLength(0), inputImage.GetLength(1)];\r\n\r\n            byte mF(int x, int y)\r\n            {\r\n                byte[] kernel = sortedFilterKernel(inputImage, size, x, y);\r\n                int median;\r\n                int h = kernel.Length / 2;\r\n                if (kernel.Length % 2 == 0) median = (kernel[h]+kernel[h-1]) / 2;\r\n                else median = kernel[h];\r\n                return ((byte)median);\r\n            }\r\n\r\n            for (int i = 0; i < inputImage.GetLength(0); i++)\r\n            {\r\n                for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                {\r\n                    tempImage[i, j] = mF(i, j);\r\n                }\r\n            }\r\n\r\n            return tempImage;\r\n        }\r\n\r\n\r\n        /*\r\n         * edgeMagnitude: calculate the image derivative of an input image and a provided edge kernel\r\n         * input:   inputImage          single-channel (byte) image\r\n         *          horizontalKernel    horizontal edge kernel\r\n         *          verticalKernel      vertical edge kernel\r\n         * output:                      single-channel (byte) image\r\n         */\r\n        private byte[,] edgeMagnitude(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel)\r\n        {\r\n            // create temporary grayscale image\r\n            GrayScaleImage tempImage = new GrayScaleImage(new byte[inputImage.GetLength(0), inputImage.GetLength(1)]);\r\n\r\n            float[,] fhk = map2D(horizontalKernel, b=> (float)0.5*b);\r\n            float[,] fvk = map2D(verticalKernel, b => (float)0.5*b);\r\n            \r\n            byte[,] h = convolveImage(inputImage, fhk);\r\n            byte[,] v = convolveImage(inputImage, fvk);\r\n\r\n            tempImage.ApplyIndexed((p, i, j) => (int)Math.Sqrt((h[i, j] * h[i, j]) + (v[i, j] * v[i, j])));\r\n            return tempImage.ToByteArray();\r\n        }\r\n\r\n\r\n        /*\r\n         * thresholdImage: threshold a grayscale image\r\n         * input:   inputImage          single-channel (byte) image\r\n         * output:                      single-channel (byte) image with on/off values\r\n         */\r\n        private byte[,] thresholdImage(byte[,] inputImage, byte threshold)\r\n        {\r\n            // create temporary grayscale image\r\n            GrayScaleImage tempImage = new GrayScaleImage(new byte[inputImage.GetLength(0), inputImage.GetLength(1)]);\r\n\r\n            tempImage.ApplyIndexed(((p, i, j) => inputImage[i,j]>threshold?byte.MaxValue:byte.MinValue));\r\n            \r\n            return tempImage.ToByteArray();\r\n        }\r\n\r\n        private byte[,] pipeline1(byte[,] inputImage, float sigma, sbyte[,] horizontalKernel, sbyte[,] verticalKernel, byte threshold)\r\n        {\r\n            float[,] filter = createGaussianFilter(filterSize, sigma);\r\n\r\n            byte[,] filteredImage = convolveImage(inputImage, filter);\r\n\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n\r\n            return thresholdedImage;\r\n        }\r\n        \r\n        private byte[,] pipeline2(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel, byte threshold)\r\n        {\r\n            byte[,] filteredImage = medianFilter(inputImage, 5);\r\n\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n\r\n            return thresholdedImage;\r\n        }\r\n\r\n        private byte[,] pipeline3_1(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel,\r\n            byte threshold)\r\n        {\r\n            byte[,] filteredImage = convolveImage(inputImage, createGaussianFilter(3, 1f));\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n            return thresholdedImage;\r\n        }\r\n        private byte[,] pipeline3_2(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel,\r\n            byte threshold)\r\n        {\r\n            byte[,] filteredImage = convolveImage(inputImage, createGaussianFilter(5, 1f));\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n            return thresholdedImage;\r\n        }\r\n        private byte[,] pipeline3_3(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel,\r\n            byte threshold)\r\n        {\r\n            byte[,] filteredImage = convolveImage(inputImage, createGaussianFilter(7, 1f));\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n            return thresholdedImage;\r\n        }\r\n        private byte[,] pipeline3_4(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel,\r\n            byte threshold)\r\n        {\r\n            byte[,] filteredImage = convolveImage(inputImage, createGaussianFilter(9, 1f));\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n            return thresholdedImage;\r\n        }\r\n        private byte[,] pipeline3_5(byte[,] inputImage, sbyte[,] horizontalKernel, sbyte[,] verticalKernel,\r\n            byte threshold)\r\n        {\r\n            byte[,] filteredImage = convolveImage(inputImage, createGaussianFilter(11, 1f));\r\n            byte[,] edgedImage = edgeMagnitude(filteredImage, horizontalKernel, verticalKernel);\r\n            byte[,] thresholdedImage = thresholdImage(edgedImage, threshold);\r\n            return thresholdedImage;\r\n        }\r\n\r\n        \r\n        // ====================================================================\r\n        // ============= YOUR FUNCTIONS FOR ASSIGNMENT 2 GO HERE ==============\r\n        // ====================================================================\r\n\r\n        public abstract class Imager<TA>\r\n        {\r\n            protected TA[,] Ar;\r\n            protected HashSet<(int u, int v)> Cps;//coordinate points\r\n            public virtual TA this[int u,int v]\r\n            {\r\n                get => Ar[u, v];\r\n                set => Ar[u, v] = value;\r\n            }\r\n\r\n            public int GetLength(int d)\r\n            {\r\n                return Ar.GetLength(d);\r\n            }\r\n\r\n            public void Apply(Func<TA,TA> op)\r\n            {\r\n                Ar = map2D(Ar, op);\r\n            }\r\n            public void ApplyIndexed(Func<TA,int,int,TA> op)\r\n            {\r\n                Ar = map2dIndexed(Ar, op);\r\n            }\r\n            public static TA[,] BinaryOp(Imager<TA> a,Imager<TA> b, Func<TA, TA, TA> op)\r\n            {\r\n                if (b.GetLength(0) != a.Ar.GetLength(0) && b.GetLength(1) != a.Ar.GetLength(1))\r\n                {\r\n                    MessageBox.Show(\"Error in image dimensions (have to be the same)\");\r\n                    throw new Exception(\"Error in image dimensions (have to be the same)\");\r\n                }\r\n                TA[,] oar = map2dIndexed(a.Ar, ((p1, i, j) => op(p1, b[i, j])));\r\n                return oar;\r\n            }\r\n            //coordinate pairs\r\n            public void UpdateCps()\r\n            {\r\n                Cps = new HashSet<(int u, int v)>(EnumerableRange2D(Ar.GetLength(0),Ar.GetLength(1))).ToHashSet();\r\n            }\r\n\r\n            public void TranslateImage(int x, int y)\r\n            {\r\n                Cps = Cps.Select(p => (p.u + x, p.v + y)).ToHashSet();\r\n            }\r\n\r\n            public bool InImage(int x, int y)\r\n            {\r\n                return x >= 0 && x < Ar.GetLength(0) && y >= 0 && y < Ar.GetLength(1);\r\n            }\r\n\r\n            public virtual byte[,] ToByteArray()\r\n            {\r\n                return map2D(Ar, p => (byte) Convert.ChangeType(p,typeof(byte)));\r\n            }\r\n        }\r\n\r\n        public class BinaryImage : Imager<bool>\r\n        {\r\n            public HashSet<(int u, int v)> Qi;\r\n            public BinaryImage(byte[,] image)\r\n            {\r\n                Ar = map2D(image, p => Convert.ToBoolean(p));\r\n                UpdateCps();\r\n                Qi = new HashSet<(int, int)>(Cps.Where(p => this[p.u, p.v]));\r\n            }\r\n            public BinaryImage(int[,] image)\r\n            {\r\n                Ar = map2D(image, p => Convert.ToBoolean(p));\r\n                UpdateCps();\r\n                Qi = new HashSet<(int, int)>(Cps.Where(p => this[p.u, p.v]));\r\n            }\r\n            public BinaryImage(bool[,] image)\r\n            {\r\n                Ar = image;\r\n                UpdateCps();\r\n                Qi = new HashSet<(int, int)>(Cps.Where(p => this[p.u, p.v]));\r\n            }\r\n\r\n            public BinaryImage(HashSet<(int u, int v)> ps,int h,int v)\r\n            {\r\n                Ar = new bool[h,v];\r\n                foreach (var p in ps){Ar[p.u, p.v] = true;}\r\n                UpdateCps(); \r\n                Qi = ps;\r\n            }\r\n\r\n            public static BinaryImage operator &(BinaryImage a, BinaryImage b)\r\n            {\r\n                return new BinaryImage(BinaryOp(a, b, ((p1, p2) => p1 && p2)));\r\n            }\r\n            public static BinaryImage operator |(BinaryImage a, BinaryImage b)\r\n            {\r\n                return new BinaryImage(BinaryOp(a, b, ((p1, p2) => p1 || p2)));\r\n            }\r\n            public static bool operator false(BinaryImage a) => !Foldl2D(((p1, p2) => p2 || p1), false, a.Ar);\r\n            public static bool operator true(BinaryImage a) => Foldl2D(((p1, p2) => p2 && p1), true, a.Ar);\r\n            \r\n            public static BinaryImage operator +(BinaryImage i, StructuringElement h) //dilation\r\n            {\r\n                return new BinaryImage((from p in i.Qi from q in h.Qh select (p.u+q.u,p.v+q.v))\r\n                    .Where((x) => i.InImage(x.Item1, x.Item2)).ToHashSet()\r\n                    ,i.GetLength(0),i.GetLength(1));\r\n            }\r\n            \r\n            public static BinaryImage operator -(BinaryImage i, StructuringElement h) //erosion\r\n            {\r\n                HashSet<(int ,int)> T((int u,int v)p) => h.Qh.Select(q => (q.u+p.u,q.v+p.v))\r\n                    .Where((x) => i.InImage(x.Item1,x.Item2)).ToHashSet();\r\n                return new BinaryImage((from p in i.Qi where(T(p).IsSubsetOf(i.Qi)) select p)\r\n                    .Where((x) => i.InImage(x.Item1,x.Item2)).ToHashSet()\r\n                    ,i.GetLength(0),i.GetLength(1));\r\n            }\r\n\r\n            public static BinaryImage operator *(BinaryImage i, StructuringElement h) => i - h + h; //opening\r\n            public static BinaryImage operator /(BinaryImage i, StructuringElement h) => i + h - h; //closing\r\n\r\n            public static BinaryImage operator ~(BinaryImage i)\r\n            {\r\n                return new BinaryImage(i.Cps.Except(i.Qi).ToHashSet(), i.GetLength(0), i.GetLength(1));\r\n            }\r\n\r\n            public BinaryImage traceBoundary()\r\n            {\r\n                StructuringElement h = new StructuringElement(ElementShape.Star, 3);\r\n                return new BinaryImage(Qi.Intersect((~(this - h)).Qi).ToHashSet(),this.GetLength(0),this.GetLength(1));\r\n            }\r\n\r\n            public override byte[,] ToByteArray()\r\n            {\r\n                return map2D(Ar, p => p?byte.MaxValue:byte.MinValue);\r\n            }\r\n        }\r\n        public class GrayScaleImage : Imager<int>\r\n        {\r\n            public GrayScaleImage(byte[,] image)\r\n            {\r\n                Ar = map2D(image, p => (int) p);\r\n                UpdateCps();\r\n            }\r\n            public GrayScaleImage(int[,] image)\r\n            {\r\n                Ar = image;\r\n                UpdateCps();\r\n            }\r\n            public byte getMax(byte[,] img)\r\n            {\r\n                return Foldl2D((v, a) => v > a ? v : a, byte.MinValue, img);\r\n            }\r\n            public byte getMin(byte[,] img)\r\n            {\r\n                return Foldl2D((v, a) => v < a ? v : a, byte.MaxValue, img);\r\n            }\r\n\r\n            public (int, Dictionary<int, int>) countValues()\r\n            {\r\n                Dictionary<int, int> Count(int v, Dictionary<int, int> counter)\r\n                {\r\n                    if (counter.ContainsKey(v)) {counter[v]++;}\r\n                    else { counter.Add(v, 1); }\r\n                    return counter;\r\n                }\r\n                var d = Foldl2D(Count\r\n                    ,new Dictionary<int,int>()\r\n                    , Ar);\r\n                return (d.Count, d);\r\n            }\r\n            \r\n            public static GrayScaleImage operator +(GrayScaleImage i, StructuringElement h) //dilation\r\n            {\r\n                int[,] ni = new int[i.Ar.GetLength(0),i.Ar.GetLength(1)];\r\n                foreach (var p in i.Cps)\r\n                {\r\n                    ni[p.u, p.v] = h.Qh.Max((q => i.InImage(p.u+q.u,p.v+q.v)?i[p.u+q.u,p.v+q.v] + h[q.u,q.v]:0));\r\n                }\r\n                return new GrayScaleImage(ni);\r\n            }\r\n            \r\n            public static GrayScaleImage operator -(GrayScaleImage i, StructuringElement h) //dilation\r\n            {\r\n                int[,] ni = new int[i.Ar.GetLength(0),i.Ar.GetLength(1)];\r\n                foreach (var p in i.Cps)\r\n                {\r\n                    ni[p.u, p.v] = h.Qh.Min((q => i.InImage(p.u+q.u,p.v+q.v)?i[p.u+q.u,p.v+q.v] + h[q.u,q.v]:int.MaxValue));\r\n                }\r\n                return new GrayScaleImage(ni);\r\n            }\r\n            public static GrayScaleImage operator *(GrayScaleImage i, StructuringElement h) => i - h + h; //opening\r\n            public static GrayScaleImage operator /(GrayScaleImage i, StructuringElement h) => i + h - h; //closing\r\n        }\r\n        public class StructuringElement : Imager<int>\r\n        {\r\n            public HashSet<(int u , int v)> Qh;\r\n            private (int x,int y) offset;\r\n            private (int x,int y) Offset\r\n            {\r\n                get => offset;\r\n                set => offset = (-(value.x - 1) / 2, -(value.y - 1) / 2);\r\n            }\r\n\r\n            public StructuringElement(ElementShape shape,int size)\r\n            {\r\n                if (size % 2 == 0)\r\n                {\r\n                    MessageBox.Show(\"Element Size is even, please enter an odd element size\");\r\n                    throw new Exception(\">:(\");\r\n                }\r\n                Ar = shape == ElementShape.Square ? new [,] {{1,1,1},{1,1,1},{1,1,1}} : new [,] {{-1,1,-1},{1,1,1},{-1,1,-1}};\r\n                UpdateCps();\r\n                Offset = (3, 3);\r\n                TranslateImage(offset.x,offset.y);\r\n                Qh = new HashSet<(int, int)>(Cps.Where(p => this[p.u, p.v] == 1));\r\n                int x = (size - 3) / 2;\r\n                if (x > 0)\r\n                {\r\n                    var s = Enumerable.Range(0, x).Aggregate(this, (se, _) => se + new StructuringElement(shape, 3));\r\n                    Qh = s.Qh;\r\n                    Cps = s.Cps;\r\n                    Ar = s.Ar;\r\n                }\r\n            }\r\n\r\n            public StructuringElement(HashSet<(int u, int v)> ps,int h,int v)\r\n            {\r\n                Ar = new int[h,v];\r\n                Offset = (h, v);\r\n                foreach (var p in ps){this[p.u, p.v] = 1;}\r\n                UpdateCps(); \r\n                Qh = ps;\r\n            }\r\n\r\n            public override int this[int u, int v]\r\n            {\r\n                get => base[u-offset.x, v-offset.y];\r\n                set => base[u-offset.x, v-offset.y] = value;\r\n            }\r\n            \r\n            public static StructuringElement operator +(StructuringElement h1, StructuringElement h2) //dilation\r\n            {\r\n                var h3 = (from p in h1.Qh from q in h2.Qh select (p.u+q.u,p.v+q.v))\r\n                    .Where((x) => h1.InImage(x.Item1, x.Item2)).ToHashSet();\r\n                return new StructuringElement(h3,h3.Max(p => Math.Abs(p.Item1)*2+1),h3.Max(p => Math.Abs(p.Item2)*2+1));\r\n            }\r\n        }\r\n\r\n        private StructuringElement createStructuringElement(ElementShape shape, int size, bool binary)\r\n        {\r\n            return new StructuringElement(shape, size);\r\n        }\r\n\r\n        /*private int[,] dilateR(int[,] structuringElement, bool binary, int x, ElementShape shape)\r\n        {\r\n            if (x <= 0)\r\n            {\r\n                return structuringElement;\r\n            }\r\n\r\n            int[,] newInput = putInCenter(structuringElement.GetLength(0) + 2, structuringElement.GetLength(1) + 2,\r\n                structuringElement);\r\n            return dilateR(dilateImage(newInput, this.structuringElement(shape, 3, binary), binary), binary, x-1, shape);\r\n        }\r\n\r\n        private int[,] putInCenter(int nw, int nh, int[,] shape)\r\n        {\r\n            int[,] tempImg = setZeros(nw, nh);\r\n            for (int i = 0; i < shape.GetLength(0); i++)\r\n            {\r\n                for (int j = 0; j < shape.GetLength(1); j++)\r\n                {\r\n                    tempImg[i + 1, j + 1] = shape[i, j];\r\n                }\r\n            }\r\n            return tempImg;\r\n        }\r\n\r\n        private int[,] setZeros(int h, int w)\r\n        {\r\n            int[,] outimg = new int[w,h];\r\n            for (int i = 0; i < w; i++)\r\n            {\r\n                for (int j = 0; j < h; j++)\r\n                {\r\n                    outimg[i, j] = 0;\r\n                }\r\n            }\r\n            return outimg;\r\n        }\r\n        private int[,] set255(int h, int w)\r\n        {\r\n            int[,] outimg = new int[w, h];\r\n            for (int i = 0; i < w; i++)\r\n            {\r\n                for (int j = 0; j < h; j++)\r\n                {\r\n                    outimg[i, j] = 255;\r\n                }\r\n            }\r\n            return outimg;\r\n        }\r\n\r\n        private int[,] dilateImage(int[,] inputImage, int[,] structuralElement, bool binary)\r\n        {\r\n            int size = structuralElement.GetLength(0);\r\n            int x = (size - 1) / 2;\r\n            int[,] outputImage = setZeros(inputImage.GetLength(1), inputImage.GetLength(0));\r\n            if (binary)\r\n            {\r\n                for (int i = 0; i < inputImage.GetLength(0); i++)\r\n                {\r\n                    for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                    {\r\n                        if (inputImage[i, j] > 127)\r\n                        {\r\n                            for (int k = -x; k <= x; k++)\r\n                            {\r\n                                for (int l = -x; l <= x; l++)\r\n                                {\r\n                                    if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&\r\n                                        j + l < inputImage.GetLength(1) && structuralElement[k+x, l+x] == 255)\r\n                                    {\r\n                                        outputImage[i + k, j + l] = 255;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for (int i = 0; i < inputImage.GetLength(0); i++)\r\n                {\r\n                    for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                    {\r\n                        int[,] temp = setZeros(structuralElement.GetLength(0), structuralElement.GetLength(1));\r\n                        for (int k = -x; k <= x; k++)\r\n                        {\r\n                            for (int l = -x; l <= x; l++)\r\n                            {\r\n                                if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&\r\n                                    j + l < inputImage.GetLength(1) && (structuralElement[k + x, l + x] != -1))\r\n                                {\r\n                                    temp[k+x, l+x] = inputImage[i + k, j + l] + structuralElement[k+x, l+x];\r\n                                    \r\n                                }\r\n                            }\r\n                        }\r\n                        //outputImage[i, j] = (int)getMax(PointOperationImage(temp, (i1, I, J) => (byte)i1));\r\n                    }\r\n                }\r\n            }\r\n            return outputImage;\r\n        }\r\n\r\n        private int[,] erodeImage(int[,] inputImage, int[,] structuralElement, bool binary)\r\n        {\r\n            int size = structuralElement.GetLength(0);\r\n            int x = (size - 1) / 2;\r\n            int[,] outputImage = setZeros(inputImage.GetLength(1), inputImage.GetLength(0));\r\n            if (binary)\r\n            {\r\n                for (int i = 0; i < inputImage.GetLength(0); i++)\r\n                {\r\n                    for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                    {\r\n                        bool check = true;\r\n                        for (int k = -x; k <= x; k++)\r\n                        {\r\n                            for (int l = -x; l <= x; l++)\r\n                            {\r\n                                if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&\r\n                                    j + l < inputImage.GetLength(1))\r\n                                {\r\n                                    check = ((inputImage[i + k, j + l] == 255 && structuralElement[k+x, l+x] == 255) || (inputImage[i+k, j+l] == 255 && structuralElement[k+x,l+x] == 0) || (inputImage[i+k, j+l] == 0 && structuralElement[k+x,l+x] == 0)) && check;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (check)\r\n                        {\r\n                            outputImage[i, j] = 255;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for (int i = 0; i < inputImage.GetLength(0); i++)\r\n                {\r\n                    for (int j = 0; j < inputImage.GetLength(1); j++)\r\n                    {\r\n                        int[,] temp = set255(structuralElement.GetLength(0), structuralElement.GetLength(1));\r\n                        for (int k = -x; k <= x; k++)\r\n                        {\r\n                            for (int l = -x; l <= x; l++)\r\n                            {\r\n                                if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&\r\n                                    j + l < inputImage.GetLength(1) && (structuralElement[k + x, l + x] != -1))\r\n                                {\r\n                                    int m = structuralElement[k + x, l + x];\r\n                                    int n = inputImage[i + k, j + l];\r\n                                    int val = n - m;\r\n                                    temp[k + x, l + x] = val < 0 ? 0 : inputImage[i + k, j + l] - structuralElement[k + x, l + x];\r\n                                }\r\n                            }\r\n                        }\r\n                        outputImage[i, j] = (int)//getMin(PointOperationImage(temp, (i1, I, J) => (byte)i1));\r\n                    }\r\n                }\r\n            }\r\n            return outputImage;\r\n        }\r\n\r\n        private int[,] openImage(int[,] inputImage, int[,] structuralElement, bool binary)\r\n        {\r\n            int[,] workingimage = inputImage;\r\n            if (binary)\r\n            {\r\n                workingimage = byteArrayToIntArray(thresholdImage(intArrayToByteArray(workingimage), threshold));\r\n            }\r\n            int[,] erodedImage = erodeImage(workingimage, structuralElement, binary);\r\n            int[,] dilatedImage = dilateImage(erodedImage, structuralElement, binary);\r\n            return dilatedImage;\r\n        }\r\n\r\n        private int[,] closeImage(int[,] inputImage, int[,] structuralElement, bool binary)\r\n        {\r\n            int[,] workingimage = inputImage;\r\n            if (binary)\r\n            {\r\n                workingimage = byteArrayToIntArray(thresholdImage(intArrayToByteArray(workingimage), threshold));\r\n            }\r\n            int[,] dilatedImage = dilateImage(workingimage, structuralElement, binary);\r\n            int[,] erodedImage = erodeImage(dilatedImage, structuralElement, binary);\r\n            return erodedImage;\r\n        }\r\n        \r\n\r\n        // ====================================================================\r\n        // ============= YOUR FUNCTIONS FOR ASSIGNMENT 3 GO HERE ==============\r\n        // ====================================================================\r\n    */\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Form1.cs b/Form1.cs
--- a/Form1.cs	(revision 3a3335f593e566b06f290459ce33e138351dc7d7)
+++ b/Form1.cs	(date 1728047181051)
@@ -45,7 +45,8 @@
             Open,
             Close,
             CountValues,
-            TraceBoundary
+            TraceBoundary,
+            HoughTransform
         }
 
         public enum ElementShape
@@ -153,6 +154,10 @@
                 Binary.Visible = false;
                 LoadImage2.Visible = true;
             }
+            else if (comboBox.SelectedIndex == 22)
+            {
+                Binary.Visible = true; 
+            }
             else
             {
                 FilterSize.Visible = false;
@@ -207,7 +212,7 @@
             {
                 if (InputImage == null) return; // get out if no input image
                 if (OutputImage != null) OutputImage.Dispose(); // reset output image
-                OutputImage = new Bitmap(InputImage.Size.Width, InputImage.Size.Height); // create new output image
+                OutputImage = new Bitmap(512, 512); // create new output image
                 Color[,]
                     Image1 = new Color[InputImage.Size.Width,
                         InputImage.Size.Height]; // create array to speed-up operations (Bitmap functions are very slow)
@@ -223,8 +228,8 @@
 
 
                 // copy array to output Bitmap
-                for (int x = 0; x < workingImage.GetLength(0); x++) // loop over columns
-                for (int y = 0; y < workingImage.GetLength(1); y++) // loop over rows
+                for (int x = 0; x < workingImage.GetLength(0) && x < OutputImage.Size.Width; x++) // loop over columns
+                for (int y = 0; y < workingImage.GetLength(1) && y < OutputImage.Size.Height; y++) // loop over rows
                 {
                     Color newColor = Color.FromArgb(workingImage[x, y], workingImage[x, y], workingImage[x, y]);
                     OutputImage.SetPixel(x, y, newColor); // set the pixel color at coordinate (x,y)
@@ -314,6 +319,10 @@
                 case ProcessingFunctions.TraceBoundary:
                     BinaryImage I2 = new BinaryImage(workingImage);
                     return I2.traceBoundary().ToByteArray();
+                case ProcessingFunctions.HoughTransform:
+                    return Binary.Checked
+                        ? new BinaryImage(workingImage).HoughTransform().ToByteArray()
+                        : new GrayScaleImage(workingImage).HoughTransform().ToByteArray();
                 default:
                     return null;
             }
@@ -407,6 +416,17 @@
             }
             return startV;
         }
+        private static TB Foldl2DIndexed<TA, TB>(Func<TA,int,int, TB, TB> f,TB startV, TA[,] filter)
+        {
+            for (int i = 0; i < filter.GetLength(0); i++) 
+            { 
+                for (int j = 0; j < filter.GetLength(1); j++)
+                {
+                    startV = f(filter[i, j], i, j, startV);
+                } 
+            }
+            return startV;
+        }
         
         private static TB Foldr2D<TA, TB>(Func<TA, TB, TB> f,TB startV, TA[,] filter)
         {
@@ -798,6 +818,8 @@
                 UpdateCps(); 
                 Qi = ps;
             }
+            
+            public GrayScaleImage HoughTransform() => HoughTransformer(Qi);
 
             public static BinaryImage operator &(BinaryImage a, BinaryImage b)
             {
@@ -857,6 +879,9 @@
                 Ar = image;
                 UpdateCps();
             }
+            
+            public GrayScaleImage HoughTransform() => HoughTransformer(Cps.Where(p => Ar[p.u,p.v] != 0).ToHashSet());
+            
             public byte getMax(byte[,] img)
             {
                 return Foldl2D((v, a) => v > a ? v : a, byte.MinValue, img);
@@ -961,198 +986,35 @@
         {
             return new StructuringElement(shape, size);
         }
-
-        /*private int[,] dilateR(int[,] structuringElement, bool binary, int x, ElementShape shape)
-        {
-            if (x <= 0)
-            {
-                return structuringElement;
-            }
-
-            int[,] newInput = putInCenter(structuringElement.GetLength(0) + 2, structuringElement.GetLength(1) + 2,
-                structuringElement);
-            return dilateR(dilateImage(newInput, this.structuringElement(shape, 3, binary), binary), binary, x-1, shape);
-        }
-
-        private int[,] putInCenter(int nw, int nh, int[,] shape)
-        {
-            int[,] tempImg = setZeros(nw, nh);
-            for (int i = 0; i < shape.GetLength(0); i++)
-            {
-                for (int j = 0; j < shape.GetLength(1); j++)
-                {
-                    tempImg[i + 1, j + 1] = shape[i, j];
-                }
-            }
-            return tempImg;
-        }
-
-        private int[,] setZeros(int h, int w)
-        {
-            int[,] outimg = new int[w,h];
-            for (int i = 0; i < w; i++)
-            {
-                for (int j = 0; j < h; j++)
-                {
-                    outimg[i, j] = 0;
-                }
-            }
-            return outimg;
-        }
-        private int[,] set255(int h, int w)
-        {
-            int[,] outimg = new int[w, h];
-            for (int i = 0; i < w; i++)
-            {
-                for (int j = 0; j < h; j++)
-                {
-                    outimg[i, j] = 255;
-                }
-            }
-            return outimg;
-        }
-
-        private int[,] dilateImage(int[,] inputImage, int[,] structuralElement, bool binary)
-        {
-            int size = structuralElement.GetLength(0);
-            int x = (size - 1) / 2;
-            int[,] outputImage = setZeros(inputImage.GetLength(1), inputImage.GetLength(0));
-            if (binary)
-            {
-                for (int i = 0; i < inputImage.GetLength(0); i++)
-                {
-                    for (int j = 0; j < inputImage.GetLength(1); j++)
-                    {
-                        if (inputImage[i, j] > 127)
-                        {
-                            for (int k = -x; k <= x; k++)
-                            {
-                                for (int l = -x; l <= x; l++)
-                                {
-                                    if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&
-                                        j + l < inputImage.GetLength(1) && structuralElement[k+x, l+x] == 255)
-                                    {
-                                        outputImage[i + k, j + l] = 255;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            else
-            {
-                for (int i = 0; i < inputImage.GetLength(0); i++)
-                {
-                    for (int j = 0; j < inputImage.GetLength(1); j++)
-                    {
-                        int[,] temp = setZeros(structuralElement.GetLength(0), structuralElement.GetLength(1));
-                        for (int k = -x; k <= x; k++)
-                        {
-                            for (int l = -x; l <= x; l++)
-                            {
-                                if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&
-                                    j + l < inputImage.GetLength(1) && (structuralElement[k + x, l + x] != -1))
-                                {
-                                    temp[k+x, l+x] = inputImage[i + k, j + l] + structuralElement[k+x, l+x];
-                                    
-                                }
-                            }
-                        }
-                        //outputImage[i, j] = (int)getMax(PointOperationImage(temp, (i1, I, J) => (byte)i1));
-                    }
-                }
-            }
-            return outputImage;
-        }
-
-        private int[,] erodeImage(int[,] inputImage, int[,] structuralElement, bool binary)
-        {
-            int size = structuralElement.GetLength(0);
-            int x = (size - 1) / 2;
-            int[,] outputImage = setZeros(inputImage.GetLength(1), inputImage.GetLength(0));
-            if (binary)
-            {
-                for (int i = 0; i < inputImage.GetLength(0); i++)
-                {
-                    for (int j = 0; j < inputImage.GetLength(1); j++)
-                    {
-                        bool check = true;
-                        for (int k = -x; k <= x; k++)
-                        {
-                            for (int l = -x; l <= x; l++)
-                            {
-                                if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&
-                                    j + l < inputImage.GetLength(1))
-                                {
-                                    check = ((inputImage[i + k, j + l] == 255 && structuralElement[k+x, l+x] == 255) || (inputImage[i+k, j+l] == 255 && structuralElement[k+x,l+x] == 0) || (inputImage[i+k, j+l] == 0 && structuralElement[k+x,l+x] == 0)) && check;
-                                }
-                            }
-                        }
-                        if (check)
-                        {
-                            outputImage[i, j] = 255;
-                        }
-                    }
-                }
-            }
-            else
-            {
-                for (int i = 0; i < inputImage.GetLength(0); i++)
-                {
-                    for (int j = 0; j < inputImage.GetLength(1); j++)
-                    {
-                        int[,] temp = set255(structuralElement.GetLength(0), structuralElement.GetLength(1));
-                        for (int k = -x; k <= x; k++)
-                        {
-                            for (int l = -x; l <= x; l++)
-                            {
-                                if (i + k >= 0 && i + k < inputImage.GetLength(0) && j + l >= 0 &&
-                                    j + l < inputImage.GetLength(1) && (structuralElement[k + x, l + x] != -1))
-                                {
-                                    int m = structuralElement[k + x, l + x];
-                                    int n = inputImage[i + k, j + l];
-                                    int val = n - m;
-                                    temp[k + x, l + x] = val < 0 ? 0 : inputImage[i + k, j + l] - structuralElement[k + x, l + x];
-                                }
-                            }
-                        }
-                        outputImage[i, j] = (int)//getMin(PointOperationImage(temp, (i1, I, J) => (byte)i1));
-                    }
-                }
-            }
-            return outputImage;
-        }
-
-        private int[,] openImage(int[,] inputImage, int[,] structuralElement, bool binary)
-        {
-            int[,] workingimage = inputImage;
-            if (binary)
-            {
-                workingimage = byteArrayToIntArray(thresholdImage(intArrayToByteArray(workingimage), threshold));
-            }
-            int[,] erodedImage = erodeImage(workingimage, structuralElement, binary);
-            int[,] dilatedImage = dilateImage(erodedImage, structuralElement, binary);
-            return dilatedImage;
-        }
-
-        private int[,] closeImage(int[,] inputImage, int[,] structuralElement, bool binary)
-        {
-            int[,] workingimage = inputImage;
-            if (binary)
-            {
-                workingimage = byteArrayToIntArray(thresholdImage(intArrayToByteArray(workingimage), threshold));
-            }
-            int[,] dilatedImage = dilateImage(workingimage, structuralElement, binary);
-            int[,] erodedImage = erodeImage(dilatedImage, structuralElement, binary);
-            return erodedImage;
-        }
-        
-
+        
         // ====================================================================
         // ============= YOUR FUNCTIONS FOR ASSIGNMENT 3 GO HERE ==============
         // ====================================================================
-    */
+        public static GrayScaleImage HoughTransformer(HashSet<(int x,int y)> edgePixels)
+        {
+            Dictionary<(int th, int r), int> accumulator = new Dictionary<(int, int), int>();
+            accumulator = edgePixels.Aggregate(accumulator,HoughAdd);
+            int w = accumulator.Keys.Max(k => k.th)+1;
+            int h = accumulator.Keys.Max(k => k.r)+1;
+            int offset = accumulator.Keys.Min(k => k.r);
+            int[,] Ar = new int[w,h-offset];
+            foreach (var pair in accumulator) { Ar[pair.Key.th,pair.Key.r-offset] = pair.Value; }
+            return new GrayScaleImage(Ar);
+        }
+        private static Dictionary<(int th, int r), int> HoughAdd(Dictionary<(int th, int r), int> aar,(int x,int y) p)
+        {
+            var e = Enumerable.Range(0, 501);
+            Dictionary<(int,int), int> Count(Dictionary<(int x,int y), int> counter,int th)
+            {
+                double thp = 2 * Math.PI * (th / 100f);
+                int r = (int)(p.x * Math.Cos(thp) + p.y * Math.Sin(thp));
+                if (counter.ContainsKey((th,r))){ if (counter[(th, r)] < 255) { counter[(th, r)]++;} }
+                else {counter.Add((th,r), 1); }
+                return counter;
+            }
+            aar = e.Aggregate(aar,Count);
+            return aar;
+        }
     }
 
 }
\ No newline at end of file
Index: .idea/.idea.INFOIBV/.idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoGeneratedRunConfigurationManager\">\r\n    <projectFile>INFOIBV.csproj</projectFile>\r\n  </component>\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"7006531f-6654-4283-8f5e-a3ed503ed201\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/.idea.INFOIBV/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/.idea.INFOIBV/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Form1.Designer.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Form1.Designer.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Form1.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Form1.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.CoreCompileInputs.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.CoreCompileInputs.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.GenerateResource.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.GenerateResource.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.exe\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.exe\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.pdb\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/x86/Debug/INFOIBV.pdb\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"HighlightingSettingsPerFile\">\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/388cbae2d6f74d9e93f2a786bd7b2c4917a648/03/34b00d9a/Enumerable.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 0\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2m0iIpHmpFypfav3gsouMD2UHjR\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \".NET Project.INFOIBV.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"ToolWindowDesigner Toolbox.ShowToolbar\": \"false\",\r\n    \"WebServerToolWindowFactoryState\": \"false\",\r\n    \"git-widget-placeholder\": \"master\",\r\n    \"ignore.virus.scanning.warn.message\": \"true\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"WinFormsDesignerOptionsPage\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  },\r\n  \"keyToStringList\": {\r\n    \"rider.external.source.directories\": [\r\n      \"C:\\\\Users\\\\julia\\\\AppData\\\\Roaming\\\\JetBrains\\\\Rider2024.1\\\\resharper-host\\\\DecompilerCache\",\r\n      \"C:\\\\Users\\\\julia\\\\AppData\\\\Roaming\\\\JetBrains\\\\Rider2024.1\\\\resharper-host\\\\SourcesCache\",\r\n      \"C:\\\\Users\\\\julia\\\\AppData\\\\Local\\\\Symbols\\\\src\"\r\n    ]\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"INFOIBV\" type=\"DotNetProject\" factoryName=\".NET Project\">\r\n      <option name=\"EXE_PATH\" value=\"\" />\r\n      <option name=\"PROGRAM_PARAMETERS\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"USE_MONO\" value=\"0\" />\r\n      <option name=\"RUNTIME_ARGUMENTS\" value=\"\" />\r\n      <option name=\"PROJECT_PATH\" value=\"$PROJECT_DIR$/INFOIBV.csproj\" />\r\n      <option name=\"PROJECT_EXE_PATH_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_ARGUMENTS_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_WORKING_DIRECTORY_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_KIND\" value=\"Console\" />\r\n      <option name=\"PROJECT_TFM\" value=\"\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"7006531f-6654-4283-8f5e-a3ed503ed201\" name=\"Changes\" comment=\"\" />\r\n      <created>1726219817959</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1726219817959</updated>\r\n      <workItem from=\"1726219820500\" duration=\"10000\" />\r\n      <workItem from=\"1727265570827\" duration=\"5210000\" />\r\n      <workItem from=\"1727428656149\" duration=\"271000\" />\r\n      <workItem from=\"1727429285415\" duration=\"12466000\" />\r\n      <workItem from=\"1727443180811\" duration=\"269000\" />\r\n      <workItem from=\"1727651842896\" duration=\"794000\" />\r\n      <workItem from=\"1727781687210\" duration=\"36000\" />\r\n      <workItem from=\"1727781745889\" duration=\"2639000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"bro\">\r\n      <created>1727615733860</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727615733860</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"UnityCheckinConfiguration\" checkUnsavedScenes=\"false\" />\r\n  <component name=\"UnityProjectConfiguration\" hasMinimizedUI=\"false\" />\r\n  <component name=\"UnityUnitTestConfiguration\" currentTestLauncher=\"Both\" />\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"CLEAR_INITIAL_COMMIT_MESSAGE\" value=\"true\" />\r\n    <MESSAGE value=\"bro\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"bro\" />\r\n  </component>\r\n  <component name=\"XSLT-Support.FileAssociations.UIState\">\r\n    <expand />\r\n    <select />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.INFOIBV/.idea/workspace.xml b/.idea/.idea.INFOIBV/.idea/workspace.xml
--- a/.idea/.idea.INFOIBV/.idea/workspace.xml	(revision 3a3335f593e566b06f290459ce33e138351dc7d7)
+++ b/.idea/.idea.INFOIBV/.idea/workspace.xml	(date 1728477513737)
@@ -9,7 +9,6 @@
   <component name="ChangeListManager">
     <list default="true" id="7006531f-6654-4283-8f5e-a3ed503ed201" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/.idea.INFOIBV/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/.idea.INFOIBV/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Form1.Designer.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Form1.Designer.cs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Form1.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Form1.cs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.CoreCompileInputs.cache" beforeDir="false" afterPath="$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.CoreCompileInputs.cache" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.GenerateResource.cache" beforeDir="false" afterPath="$PROJECT_DIR$/obj/x86/Debug/INFOIBV.csproj.GenerateResource.cache" afterDir="false" />
@@ -25,7 +24,10 @@
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
   <component name="HighlightingSettingsPerFile">
+    <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/1af41839925b4409b823837d7b5f29d691940/4b/3313b13a/Bitmap.cs" root0="SKIP_HIGHLIGHTING" />
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/388cbae2d6f74d9e93f2a786bd7b2c4917a648/03/34b00d9a/Enumerable.cs" root0="SKIP_HIGHLIGHTING" />
+    <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/e585f5e2b21741c8a3a65b4f9abfa5e8572e20/a1/ae37394d/Convert.cs" root0="SKIP_HIGHLIGHTING" />
+    <setting file="mock://C:/Users/arthu/OneDrive/Bureaublad/UU/BV/Form1.cs" root0="SKIP_HIGHLIGHTING" />
   </component>
   <component name="MarkdownSettingsMigration">
     <option name="stateVersion" value="1" />
@@ -39,30 +41,30 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    ".NET Project.INFOIBV.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "ToolWindowDesigner Toolbox.ShowToolbar": "false",
-    "WebServerToolWindowFactoryState": "false",
-    "git-widget-placeholder": "master",
-    "ignore.virus.scanning.warn.message": "true",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "settings.editor.selected.configurable": "WinFormsDesignerOptionsPage",
-    "vue.rearranger.settings.migration": "true"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;.NET Project.INFOIBV.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;ToolWindowDesigner Toolbox.ShowToolbar&quot;: &quot;false&quot;,
+    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
+    &quot;ignore.virus.scanning.warn.message&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;WinFormsDesignerOptionsPage&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
   },
-  "keyToStringList": {
-    "rider.external.source.directories": [
-      "C:\\Users\\julia\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\DecompilerCache",
-      "C:\\Users\\julia\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\SourcesCache",
-      "C:\\Users\\julia\\AppData\\Local\\Symbols\\src"
+  &quot;keyToStringList&quot;: {
+    &quot;rider.external.source.directories&quot;: [
+      &quot;C:\\Users\\julia\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\DecompilerCache&quot;,
+      &quot;C:\\Users\\julia\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\SourcesCache&quot;,
+      &quot;C:\\Users\\julia\\AppData\\Local\\Symbols\\src&quot;
     ]
   }
-}]]></component>
+}</component>
   <component name="RunManager">
     <configuration name="INFOIBV" type="DotNetProject" factoryName=".NET Project">
       <option name="EXE_PATH" value="" />
